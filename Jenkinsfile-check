#!/usr/bin/env groovy

def buildParams = [:]

runBuild {
   stage('prepare build') {
      buildParams = generateParams()
      println buildParams
   }
   stage('checkout') {
      checkout([
            $class                           : 'GitSCM',
            branches                         : scm.branches,
            userRemoteConfigs                : scm.userRemoteConfigs,
            submoduleCfg                     : [],
            doGenerateSubmoduleConfigurations: false,
            extensions                       : [
                  [$class: 'CleanBeforeCheckout'],
                  [$class : 'CloneOption',
                   shallow: true,
                   depth  : 10,
                   noTags : true,
                   timeout: 30]
            ]
      ])
      stash name: 'sources'
   }
   stage('tests') {
      tests = [:]
      for (String task : buildParams.TEST_TASKS) {
         tests[(task)] = createTestStep("app:${task}", buildParams.TEST_REPORT_FOLDER, buildParams.TEST_REPORT_PATTERN)

      }
      parallel tests
   }
   stage('assemble') {
      gradlew "app:${buildParams.ASSEMBLE_TASK}"
   }
}

@NonCPS
def Map generateParams() {
   def buildParams = [:]

   def flavors = [
         stable   : "Stable",
         social   : "Social",
         dtl      : "Dtl",
         messenger: "Messenger",
         smartcard: "Smartcardmock",
   ]

   buildParams.FLAVOR = flavors.stable
   if (env.GITHUB_PR_TARGET_BRANCH.contains("social/")) buildParams.FLAVOR = flavors.social
   else if (env.GITHUB_PR_TARGET_BRANCH.contains("dtl/")) buildParams.FLAVOR = flavors.dtl
   else if (env.GITHUB_PR_TARGET_BRANCH.contains("messenger/")) buildParams.FLAVOR = flavors.messenger
   else if (env.GITHUB_PR_TARGET_BRANCH.contains("smart-card/")) buildParams.FLAVOR = flavors.smartcard

   if (buildParams.FLAVOR == flavors.stable) {
      buildParams.TEST_TASKS = flavors.values().collect { flavor -> "testExternal${flavor}PreprodDebug" }
   } else {
      buildParams.TEST_TASKS = ["testExternal${buildParams.FLAVOR}StageDebug"]
   }

   buildParams.ASSEMBLE_TASK = "assembleExternal${buildParams.FLAVOR}StageDebug"

   buildParams.TEST_REPORT_FOLDER = 'app/build/test-results'
   buildParams.TEST_REPORT_PATTERN = '**/*.xml'

   return buildParams
}

def createTestStep(String task, String reportFolder, String reportPattern) {
   return {
      node('android') {
         deleteDir()
         unstash 'sources'
         runTestAndArchiveResult(task, reportFolder, reportPattern)
      }
   }
}

def runBuild(Closure<Void> task) {
   notifyGithub('STARTED')
   catchError {
      decorateBuild {
         task()
      }
   }
   notifyGithub(currentBuild.result)
}

def decorateBuild(Closure<Void> task) {
   node('android') {
      currentBuild.result = 'SUCCESS'
      wrap([$class: 'TimestamperBuildWrapper']) {
         ansiColor('XTerm') {
            task()
         }
      }
   }
}

def runTestAndArchiveResult(String gradleTestTask, String reportFolder, String reportPattern) {
   Throwable error = null
   try {
      gradlew gradleTestTask
   } catch (e) {
      error = e
   }
   if (!fileExists(reportFolder)) throw error
   junit allowEmptyResults: true, testResults: "${reportFolder}/${reportPattern}"
}

def notifyGithub(String result) {
   switch (result) {
      case 'STARTED':
         setGitHubPullRequestStatus(context: env.JOB_NAME, message: "Build started", state: 'PENDING')
         break
      case 'FAILURE':
         setGitHubPullRequestStatus(context: env.JOB_NAME, message: "Build error", state: 'ERROR')
         break
      case 'UNSTABLE':
         setGitHubPullRequestStatus(context: env.JOB_NAME, message: "Tests are broken", state: 'FAILURE')
         break
      case 'SUCCESS':
         setGitHubPullRequestStatus(context: env.JOB_NAME, message: "All is good", state: 'SUCCESS')
         break
   }
}

def gradlew(String task) {
   bash "./gradlew clean ${task} -PdisablePreDex "
}

def bash(String command) {
   println "Bash shell executes -> $command"
   sh(script: """#!/bin/bash -l
      $command
    """)
}
