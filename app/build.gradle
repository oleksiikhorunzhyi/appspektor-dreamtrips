apply from: "$rootProject.projectDir/buildsystem/android-config.gradle"
apply from: "$rootProject.projectDir/buildsystem/app-config.gradle"
apply from: "$rootProject.projectDir/buildsystem/env-default-config.gradle"
apply from: "$rootProject.projectDir/buildsystem/env-flavor-config.gradle"
apply from: "$rootProject.projectDir/buildsystem/env-flavor-utils.gradle"
apply from: "$rootProject.projectDir/buildsystem/plugin-dependencies.gradle"
apply from: "$rootProject.projectDir/buildsystem/module-dependencies.gradle"
//
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'me.tatarka.retrolambda'
apply plugin: 'io.fabric'
apply plugin: 'newrelic'
apply plugin: 'com.github.ben-manes.versions'

android {
   compileSdkVersion project.ext.androidConfig.compileSdk
   buildToolsVersion project.ext.androidConfig.buildTools

   defaultConfig {
      applicationId = project.ext.appConfig.applicationId
      versionCode project.ext.appConfig.buildVersionCode()
      versionName project.ext.appConfig.buildVersionName()
      archivesBaseName = project.ext.appConfig.archivesBaseName
      //
      minSdkVersion project.ext.androidConfig.minSdk
      targetSdkVersion project.ext.androidConfig.targetSdk
      //
      multiDexEnabled true
   }

   flavorDimensions "build", "stream", "config"

   productFlavors {
      // "build"-dimension flavors:
      dev {
         dimension "build"
         applicationIdSuffix = 'dev'
         minSdkVersion 23
      }
      devpremarshmallow {
         dimension "build"
         applicationIdSuffix = 'dev'
      }
      external { dimension "build" }
      // "stream"-dimension flavors:
      dtl {
         dimension "stream"
         applicationIdSuffix = 'dtl'
      }
      messenger {
         dimension "stream"
         applicationIdSuffix = 'messenger'
      }
      social {
         dimension "stream"
         applicationIdSuffix = 'social'
      }
      smartcardmock {
         dimension "stream"
         applicationIdSuffix = 'smartcard'
      }
      smartcardnxtid {
         dimension "stream"
         applicationIdSuffix = 'smartcard'
      }
      stable { dimension "stream" }
      // "config"-dimension flavors:
      stage {
         dimension "config"
         applicationIdSuffix = 'stage'
      }
      preprod {
         dimension "config"
         applicationIdSuffix = 'preprod'
      }
      integration {
         dimension "config"
         applicationIdSuffix = 'integration'
      }
      perf {
         dimension "config"
         applicationIdSuffix = 'perf'
      }
      prod {
         dimension "config"
      }
   }

   variantFilter { variant ->
      variant.ignore = !project.ext.flavors.acceptVariant(variant)
   }

   android.applicationVariants.all { variant ->
      project.ext.flavors.applyConfig(variant)
      project.ext.flavors.applyVersionName(variant)
   }

   signingConfigs {
      debug {
         storeFile rootProject.file('debug.keystore')
      }
      release {
         Properties signingProperties = new Properties()
         def pFile = rootProject.file('signing/signing.properties')
         if (pFile.exists()) {
            signingProperties.load(new FileInputStream(pFile))
            storeFile rootProject.file("signing/" + signingProperties.storeFile)
            storePassword signingProperties.storePassword
            keyAlias signingProperties.keyAlias
            keyPassword signingProperties.keyPassword
         }
      }
   }

   buildTypes {
      debug {
         debuggable true
         signingConfig signingConfigs.debug
         applicationIdSuffix ".debug"
         versionNameSuffix "-debug"
      }
      release {
         minifyEnabled true
         shrinkResources true
         signingConfig signingConfigs.release
         // proguard
         def proConfigs = file('proguard-rules').listFiles().collect { it }
         proConfigs << getDefaultProguardFile('proguard-android-optimize.txt')
         proConfigs << file('dagger-proguard-keepnames.cfg')
         setProguardFiles proConfigs
      }
   }

   compileOptions {
      sourceCompatibility project.ext.pluginDependencies.languages.java
      targetCompatibility project.ext.pluginDependencies.languages.java
   }
   testOptions {
      unitTests.returnDefaultValues = true
   }
   dexOptions {
      javaMaxHeapSize "4g"
      keepRuntimeAnnotatedClasses false
      preDexLibraries = project.ext.androidConfig.preDex
   }
   lintOptions {
      disable 'MissingTranslation' // otherwise generated strings fucks you up
      abortOnError false
      checkReleaseBuilds false
      // lint doesn't like retrolambda https://github.com/evant/gradle-retrolambda/issues/96
   }
   packagingOptions {
      exclude 'LICENSE.txt'
      exclude 'META-INF/services/javax.annotation.processing.Processor'
      exclude 'META-INF/LICENSE.txt'
      exclude 'META-INF/NOTICE.txt'
   }
   useLibrary 'org.apache.http.legacy'

   dataBinding{
      enabled = true
   }

   sourceSets {
      smartcardnxtid {
         test.java.srcDirs += 'src/testSmartCardMock/java'
      }
      smartcardmock {
         test.java.srcDirs += 'src/testSmartCardMock/java'
      }
      social {
         test.java.srcDirs += 'src/testSocial/java'
      }
   }

}

// disable new relic for non-release tasks

task('disableNR') {
   doLast {
      logger.info("[newrelic] newRelicInstrumentTask will be disabled")
      try {
         newRelicInstrumentTask.enabled = false
         newRelicDeinstrumentTask.enabled = false
      } catch (Exception e) {
         logger.log(LogLevel.ERROR, "[newrelic] an error occured attempting to disable New Relic instrumentation." + "\n" + e.printStackTrace())
      }
      if (newRelicInstrumentTask.enabled == true) {
         logger.log(LogLevel.ERROR, "[newrelic] an error occured attempting to disable New Relic instrumentation.")
      } else {
         logger.info("[newrelic] newrelicInstrumentTask has been disabled")
      }
   }
}

tasks.whenTaskAdded { task ->
   if (task.name.startsWith("transformClassesWithDexFor") && (task.name.toLowerCase().contains("dev") || task.name.toLowerCase().contains("debug"))) {
      task.dependsOn disableNR
   }
}

// increase max errors output

tasks.withType(JavaCompile) {
   options.compilerArgs << "-Xmaxerrs" << "400"
}

// configuration & dependencies

def deps = project.ext.moduleDependencies

configurations.all {
   resolutionStrategy {
      cacheChangingModulesFor 0, 'seconds'
      force deps.provide(deps.rx.rxjava)
      force deps.provide(deps.util.mappery)
   }
   exclude group: 'xpp3', module: 'xpp3'
   exclude group: 'org.jetbrains', module: 'annotations-java5'
}

repositories {
   project.ext.moduleDependencies.repos.each { it.call(owner) }
}

dependencies {
   compile fileTree(dir: 'libs', include: ['*.jar'])

   deps.applyAll(owner, deps.lang)
   deps.applyAll(owner, deps.domain)
   deps.applyAll(owner, deps.rx)
   deps.applyAll(owner, deps.di.findAll {
      it.value != deps.di.daggerProguard
   })
   deps.applyAll(owner, deps.data)
   deps.applyAll(owner, deps.networking.findAll {
      it.value != deps.networking.apiMonolith
   })
   deps.applyAll(owner, deps.smartcard)
   deps.applyAll(owner, deps.services)
   deps.applyAll(owner, deps.media)
   deps.applyAll(owner, deps.presentation)
   deps.applyAll(owner, deps.ui)
   deps.applyAll(owner, deps.util.findAll {
      ![
            deps.util.leakcanary,
            deps.util.leakcanaryNoOp,
            deps.util.jodaTimeAndroid,
      ].contains(it.value)
   })
   deps.applyAll(owner, deps.test)

   // customized dependencies

   compile(deps.provide(deps.networking.apiMonolith)) {
      exclude group: 'joda-time'
   }
   devCompile deps.provide(deps.util.leakcanary)
   devpremarshmallowCompile deps.provide(deps.util.leakcanary)
   externalCompile deps.provide(deps.util.leakcanaryNoOp)

   debugCompile(deps.provide(deps.util.jodaTimeAndroid))
   releaseCompile(deps.provide(deps.util.jodaTimeAndroid))

   releaseAnnotationProcessor deps.provide(deps.di.daggerProguard)
}
